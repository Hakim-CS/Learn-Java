Design patterns are general, reusable solutions to common problems that occur in software design. They represent best practices refined over time by experienced developers. Rather than providing finished code, design patterns offer templates or blueprints for solving specific design issues.

There are three main categories of design patterns:

1. Creational Patterns
These patterns deal with object creation mechanisms, aiming to create objects in a manner suitable to the situation. The main goal is to make a system independent of how its objects are created, composed, and represented.

Examples:

Singleton: Ensures a class has only one instance and provides a global point of access.
Factory Method: Defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.
Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
Builder: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.
Prototype: Creates new objects by copying an existing object (prototype).
2. Structural Patterns
These patterns focus on how classes and objects are composed to form larger structures. They help ensure that if one part of a system changes, the entire system doesn’t need to do the same.

Examples:

Adapter: Allows incompatible interfaces to work together by acting as a bridge between two incompatible interfaces.
Decorator: Adds new functionality to an existing object without altering its structure.
Facade: Provides a simplified interface to a complex subsystem.
Composite: Composes objects into tree structures to represent part-whole hierarchies.
Proxy: Provides a surrogate or placeholder for another object to control access to it.
3. Behavioral Patterns
These deal with object collaboration and responsibility, focusing on how objects communicate and interact with each other.

Examples:

Observer: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.
Strategy: Enables selecting an algorithm’s behavior at runtime.
Command: Encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations.
State: Allows an object to change its behavior when its internal state changes.
Template Method: Defines the skeleton of an algorithm in a method, deferring some steps to subclasses.
